<!DOCTYPE html>













<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

  
  <title>SQL必知必会 - viaxizhong</title>

  
  
  <meta name="description" content="学习极客时间的《SQL必知必会》" />
  <meta name="author" content="" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="https://viaxiz.github.io/app.min.css" />

  
  <link rel="preload stylesheet" as="style" href="https://viaxiz.github.io/an-old-hope.min.css" />
  <script
    defer
    src="https://viaxiz.github.io/highlight.min.js"
    onload="hljs.initHighlightingOnLoad();"
  ></script>
  

  
  <link rel="preload" as="image" href="https://viaxiz.github.io/theme.png" />

  
  <link rel="preload" as="image" href="https://viaxiz.github.io/github.svg" />
  

  
  <link rel="icon" href="https://viaxiz.github.io/favicon.ico" />
  <link rel="apple-touch-icon" href="https://viaxiz.github.io/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.88.1" />

  
  

  
  
  
  
  
  
  
  <meta property="og:title" content="SQL必知必会" />
<meta property="og:description" content="学习极客时间的《SQL必知必会》" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://viaxiz.github.io/posts/sql/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-19T00:21:29+08:00" />
<meta property="article:modified_time" content="2023-06-19T00:21:29+08:00" />


  
  <meta itemprop="name" content="SQL必知必会">
<meta itemprop="description" content="学习极客时间的《SQL必知必会》"><meta itemprop="datePublished" content="2023-06-19T00:21:29+08:00" />
<meta itemprop="dateModified" content="2023-06-19T00:21:29+08:00" />
<meta itemprop="wordCount" content="2833">
<meta itemprop="keywords" content="学习,SQL," />
  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="SQL必知必会"/>
<meta name="twitter:description" content="学习极客时间的《SQL必知必会》"/>

  
  
</head>


  <body class="not-ready" data-menu="true">
    <header class="header">


  
  <link rel="stylesheet"
  href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/vs.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <script>
  document.addEventListener('DOMContentLoaded', (event) => {
    document.querySelectorAll('pre code').forEach((el) => {
      hljs.highlightElement(el);
    });
  });
  </script>
  

  
  <p class="logo">
    <a class="site-name" href="https://viaxiz.github.io/">viaxizhong</a><a class="btn-dark"></a>
  </p>
  

  <script>
    let bodyClx = document.body.classList;
    let btnDark = document.querySelector('.btn-dark');
    let sysDark = window.matchMedia('(prefers-color-scheme: dark)');
    let darkVal = localStorage.getItem('dark');

    let setDark = (isDark) => {
      bodyClx[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark ? 'yes' : 'no');
    };

    setDark(darkVal ? darkVal === 'yes' : sysDark.matches);
    requestAnimationFrame(() => bodyClx.remove('not-ready'));

    btnDark.addEventListener('click', () => setDark(!bodyClx.contains('dark')));
    sysDark.addEventListener('change', (event) => setDark(event.matches));
  </script>

  
  
  <nav class="menu">
    
    <a class="" href="/about/">About</a>
    
    <a class="" href="/posts/">Post</a>
    
  </nav>
  

  
  <nav class="social">
    
    <a
      class="github"
      style="--url: url(./github.svg)"
      href="https://github.com/Viaxiz"
      target="_blank"
    ></a>
    
  </nav>
  
</header>


    <main class="main">

<article class="post-single">
  <header class="post-title">
    <h1>SQL必知必会</h1>
    <p>
      <time>Jun 19, 2023</time>
      
    </p>
  </header>
  <section class="post-content"><p>极客时间《SQL必知必会》笔记</p>
<ul>
<li><a href="#sql%E5%A6%82%E4%BD%95%E8%A2%AB%E6%89%A7%E8%A1%8C">SQL如何被执行</a>
<ul>
<li><a href="#%E5%9C%A8oracle%E4%B8%AD">在Oracle中</a></li>
<li><a href="#%E5%9C%A8mysql%E4%B8%AD">在MySQL中</a></li>
</ul>
</li>
<li><a href="#ddl%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E8%A1%A8">DDL创建数据库&amp;数据表</a>
<ul>
<li><a href="#table">TABLE</a>
<ul>
<li><a href="#%E5%AE%9A%E4%B9%89table">定义TABLE</a></li>
<li><a href="#%E4%BF%AE%E6%94%B9table">修改TABLE</a></li>
<li><a href="#%E5%B8%B8%E8%A7%81%E7%BA%A6%E6%9D%9F">常见约束</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#select">SELECT</a>
<ul>
<li><a href="#%E6%9F%A5%E8%AF%A2%E8%AF%AD%E6%B3%95">查询语法</a>
<ul>
<li><a href="#1%E6%9F%A5%E8%AF%A2%E5%88%97">1.查询列</a></li>
<li><a href="#2%E8%B5%B7%E5%88%AB%E5%90%8Das">2.起别名(AS)</a></li>
<li><a href="#3%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%A1%8Cdistinct">3.去除重复行(DISTINCT)</a></li>
</ul>
</li>
<li><a href="#%E6%8E%92%E5%BA%8F%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AEorder-by">排序检索数据(ORDER BY)</a></li>
<li><a href="#%E7%BA%A6%E6%9D%9F%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%9A%84%E6%95%B0%E9%87%8Flimit">约束返回结果的数量(LIMIT)</a>
<ul>
<li><a href="#limit%E6%9B%B4%E5%A4%9A%E5%86%85%E5%AE%B9">LIMIT更多内容</a></li>
</ul>
</li>
<li><a href="#select%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F">SELECT的执行顺序</a></li>
<li><a href="#%E8%BF%87%E6%BB%A4where">过滤（WHERE）</a>
<ul>
<li><a href="#1%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6">1.比较运算符</a></li>
<li><a href="#2%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6">2.逻辑运算符</a></li>
<li><a href="#3%E9%80%9A%E9%85%8D%E7%AC%A6like">3.通配符（LIKE）</a></li>
<li><a href="#%E7%BB%83%E4%B9%A0">练习</a></li>
</ul>
</li>
<li><a href="#sql%E5%87%BD%E6%95%B0">SQL函数</a>
<ul>
<li><a href="#1-%E7%AE%97%E6%95%B0%E5%87%BD%E6%95%B0">1. 算数函数</a></li>
<li><a href="#2%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0">2.字符串函数</a></li>
<li><a href="#3%E6%97%A5%E6%9C%9F%E5%87%BD%E6%95%B0">3.日期函数</a></li>
<li><a href="#4%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0">4.转换函数</a></li>
<li><a href="#%E8%A7%84%E8%8C%83">规范</a></li>
<li><a href="#%E7%BB%83%E4%B9%A0-1">练习</a></li>
<li><a href="#5%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0countmaxminsumavg">5.聚集函数(COUNT、MAX、MIN、SUM、AVG)</a>
<ul>
<li><a href="#%E5%88%86%E7%BB%84group-by">分组(GROUP BY)</a></li>
<li><a href="#%E8%BF%87%E6%BB%A4%E5%88%86%E7%BB%84having">过滤分组(HAVING)</a></li>
</ul>
</li>
<li><a href="#%E7%BB%83%E4%B9%A0-2">练习</a></li>
</ul>
</li>
<li><a href="#%E5%AD%90%E6%9F%A5%E8%AF%A2">子查询</a>
<ul>
<li><a href="#%E9%9D%9E%E5%85%B3%E8%81%94%E5%AD%90%E6%9F%A5%E8%AF%A2">非关联子查询</a></li>
<li><a href="#%E5%85%B3%E8%81%94%E5%AD%90%E6%9F%A5%E8%AF%A2">关联子查询</a></li>
<li><a href="#exists%E5%AD%90%E6%9F%A5%E8%AF%A2">EXISTS子查询</a></li>
<li><a href="#%E9%9B%86%E5%90%88%E6%AF%94%E8%BE%83%E5%AD%90%E6%9F%A5%E8%AF%A2inanyallsome">集合比较子查询(IN、ANY、ALL、SOME)</a></li>
<li><a href="#%E5%B0%86%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BD%9C%E4%B8%BA%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5">将子查询作为计算字段</a></li>
<li><a href="#%E7%BB%83%E4%B9%A0-3">练习</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%BF%9E%E6%8E%A5">连接</a>
<ul>
<li><a href="#sql92">SQL92</a>
<ul>
<li><a href="#%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF">笛卡尔积</a></li>
<li><a href="#%E7%AD%89%E5%80%BC%E8%BF%9E%E6%8E%A5">等值连接</a></li>
<li><a href="#%E9%9D%9E%E7%AD%89%E5%80%BC%E8%BF%9E%E6%8E%A5">非等值连接</a></li>
<li><a href="#%E5%A4%96%E8%BF%9E%E6%8E%A5">外连接</a></li>
<li><a href="#%E8%87%AA%E8%BF%9E%E6%8E%A5">自连接</a></li>
<li><a href="#%E7%BB%83%E4%B9%A0-4">练习</a></li>
</ul>
</li>
<li><a href="#sql99">SQL99</a>
<ul>
<li><a href="#%E4%BA%A4%E5%8F%89%E8%BF%9E%E6%8E%A5cross-join">交叉连接(CROSS JOIN)</a></li>
<li><a href="#%E8%87%AA%E7%84%B6%E8%BF%9E%E6%8E%A5">自然连接</a></li>
<li><a href="#on%E8%BF%9E%E6%8E%A5">ON连接</a></li>
<li><a href="#using-%E8%BF%9E%E6%8E%A5">USING 连接</a></li>
<li><a href="#%E5%A4%96%E8%BF%9E%E6%8E%A5-1">外连接</a></li>
<li><a href="#%E8%87%AA%E8%BF%9E%E6%8E%A5-1">自连接</a></li>
</ul>
</li>
<li><a href="#%E5%8C%BA%E5%88%AB">区别</a></li>
<li><a href="#%E4%B8%8D%E5%90%8C-dbms-%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%BF%9E%E6%8E%A5%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9">不同 DBMS 中使用连接需要注意的地方</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
<li><a href="#%E7%BB%83%E4%B9%A0-5">练习</a></li>
</ul>
</li>
</ul>
<p>关于 SQL 大小写的问题，总结了下面两点：</p>
<ol>
<li>表名、表别名、字段名、字段别名等都小写；</li>
<li>SQL 保留字、函数名、绑定变量等都大写。</li>
</ol>
<p>eg:</p>
<blockquote>
<p>SELECT name, hp_max FROM heros WHERE role_main = &lsquo;战士&rsquo;</p>
</blockquote>
<h1 id="sql如何被执行">SQL如何被执行</h1>
<h2 id="在oracle中">在Oracle中</h2>
<figure><img src="SQL%e5%bf%85%e7%9f%a5%e5%bf%85%e4%bc%9a-%e6%9e%81%e5%ae%a2%e6%97%b6%e9%97%b4.assets/image-20230518111151901.png" width="90%"/>
</figure>

<ol>
<li>
<p>语法检查：检查 SQL <strong>拼写是否正确</strong>，如果不正确，Oracle 会报语法错误。</p>
</li>
<li>
<p>语义检查：检查 SQL 中的<strong>访问对象是否存在</strong>。比如我们在写 SELECT 语句的时候，<strong>列名写错了，系统就会提示错误</strong>。语法检查和语义              检查的作用是保证 SQL 语句没有错误。</p>
</li>
<li>
<p>权限检查：看用户是否具备<strong>访问该数据的权限</strong>。</p>
</li>
<li>
<p>共享池检查：共享池（Shared Pool）是一块内存池，最主要的作用是<strong>缓存 SQL 语句和该语句的执行计划</strong>。Oracle 通过检查共享池是否存在 SQL 语句的执行计划，来判断进行软解析，还是硬解析。</p>
</li>
<li>
<p>在共享池中，Oracle 首先对 SQL 语句进行 Hash 运算，然后根据 Hash 值在库缓存（Library Cache）中查找，如果存在 SQL 语句的执行计划，就直接拿来执行，直接进入“执行器”的环节，这就是软解析。</p>
</li>
<li>
<p>如果没有找到 SQL 语句和执行计划，Oracle 就需要创建解析树进行解析，生成执行计划，进入“优化器”这个步骤，这就是硬解析。</p>
</li>
</ol>
<p>共享池是 Oracle 中的术语，包括了库缓存，数据字典缓冲区等。</p>
<ol>
<li>
<p>库缓存区，它主要缓存 SQL 语句和执行计划。</p>
</li>
<li>
<p>数据字典缓冲区存储的是 Oracle 中的对象定义，比如表、视图、索引等对象。</p>
<p>当对 SQL 语句进行解析的时候，如果需要相关的数据，会从数据字典缓冲区中提取。</p>
<p>库缓存这一个步骤，决定了 SQL 语句是否需要进行硬解析。为了提升 SQL 的执行效率，我们应该尽量避免硬解析，因为在 SQL 的执行过程中，创建解析树，生成执行计划是很消耗资源的。</p>
<p>在Oracle 中，绑定变量是它的一大特色。绑定变量就是在SQL 语句中使用变量，通过不同的变量取值来改变 SQL 的执行结果。这样做的好处是能提升软解析的可能性，不足之处在于可能会导致生成的执行计划不够优化，因此是否需要绑定变量还需要视情况而定。</p>
<p>eg:</p>
<blockquote>
<p>select * from player where player_id = 10001;</p>
</blockquote>
<p>绑定变量的形式就是
<code>sql select * from player where player_id = :player_id;</code></p>
<p>这种方式意味着在查询player_id = 10001之后，还会查询10002、10003之类的数据，软解析的方式会在第一次查询之后，在共享池中存在这类查询的执行计划。虽然减少了Oracle的解析工作量，但是使用动态SQL的方式，因为参数不同，会导致SQL的执行效率不同，同时SQL的优化也比较困难。</p>
</li>
<li>
<p>优化器：优化器中就是要进行硬解析，也就是决定怎么做，比如<strong>创建解析树，生成执行计划</strong>。</p>
</li>
<li>
<p>执行器：当有了解析树和执行计划之后，就知道了 SQL该怎么被执行，这样就可以在<strong>执行器中执行语句</strong>了。</p>
</li>
</ol>
<h2 id="在mysql中">在MySQL中</h2>
<figure><img src="SQL%e5%bf%85%e7%9f%a5%e5%bf%85%e4%bc%9a-%e6%9e%81%e5%ae%a2%e6%97%b6%e9%97%b4.assets/image-20230518120024440.png" width="90%"/>
</figure>

<p>MySQL是典型的C/S架构。mysqld是服务端程序。
<figure><img src="SQL%e5%bf%85%e7%9f%a5%e5%bf%85%e4%bc%9a-%e6%9e%81%e5%ae%a2%e6%97%b6%e9%97%b4.assets/image-20230518120147792.png" width="50%"/>
</figure>
</p>
<ol>
<li>查询缓存：Server 如果在查询缓存中发现了这条 SQL 语句，就会直接将结果返回给客户端；如果没有，就进入到解析器阶段。需要说明的是，因为查询缓存往往效率不高，所以在 MySQL8.0 之后就抛弃了这个功能。</li>
<li>一旦数据表有更新，缓存都将清空，因此只有数据表是静态的时候，或者数据表很少发生变化时，使用缓存查询才有价值，否则如果数据表经常更新，反而增加了SQL 的查询时间。</li>
<li>解析器：在解析器中对 SQL 语句进行语法分析、语义分析。</li>
<li>优化器：在优化器中会确定 SQL 语句的执行路径，比如是根据全表检索，还是根据索引来检索等。</li>
<li>执行器：在执行之前需要判断该用户是否具备权限，如果具备权限就执行 SQL 查询并返回结果。在 MySQL8.0 以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存。</li>
</ol>
<p>与 Oracle 不同的是，MySQL 的存储引擎采用了插件的形式，每个存储引擎都面向一种特定的数据库应用环境。同时开源的 MySQL 还允许开发人员设置自己的存储引擎，下面是一些常见的存储引擎：</p>
<ol>
<li>InnoDB 存储引擎：它是 MySQL 5.5 版本之后默认的存储引擎，最大的特点是<strong>支持事务、行级锁定、外键约束</strong>等。</li>
<li>MyISAM 存储引擎：在 MySQL 5.5 版本之前是默认的存储引擎，<strong>不支持事务，也不支持外键，最大的特点是速度快，占用资源少</strong>。</li>
<li>Memory 存储引擎：使用系统内存作为存储介质，以便得到更快的响应速度。不过如果 mysqld 进程崩溃，则会导致所有的数据丢失，因此我们只有当数据是临时的情况下才使用 Memory 存储引擎。</li>
<li>NDB 存储引擎：也叫做 NDB Cluster 存储引擎，主要用于 MySQL Cluster 分布式集群环境，类似于 Oracle 的RAC 集群。</li>
<li>Archive 存储引擎：它有很好的压缩机制，用于文件归档，在请求写入时会进行压缩，所以也经常用来做仓库。</li>
</ol>
<p>开启profiling能够查看MySQL在执行SQL语句过程中的所使用的资源情况</p>
<blockquote>
<p>mysql&gt; select @@profiling;</p>
</blockquote>
<blockquote>
<p>mysql&gt; set profiling=1;</p>
</blockquote>
<blockquote>
<p>mysql&gt; show profiles;</p>
</blockquote>
<blockquote>
<p>myslq&gt; show profile for query num_x;</p>
</blockquote>
<h1 id="ddl创建数据库数据表">DDL创建数据库&amp;数据表</h1>
<p>DDL 的英文全称是 Data Definition Language</p>
<blockquote>
<p>CREATE/DROP DATABASE nba;</p>
</blockquote>
<blockquote>
<p>CREATE TABLE player  (</p>
<p>​	player_id int(11) NOT NULL AUTO_INCREMENT,</p>
<p>​	player_name varchar(255) NOT NULL</p>
<p>);</p>
</blockquote>
<p>数据类型中 int(11) 代表整数类型，显示长度为 11 位，括号中的参数 11 代表的是最大有效显示长度，与类型包含的数值范围大小无关。
varchar(255)代表的是最大长度为 255 的可变字符串类型。NOT NULL表明整个字段不能是空值，是一种数据约束。AUTO_INCREMENT代表<strong>主键自动增长</strong>。</p>
<p>使用Navicat设计好表然后转存SQL，可以得到</p>
<h2 id="table">TABLE</h2>
<h3 id="定义table">定义TABLE</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#66d9ef">IF</span> <span style="color:#66d9ef">EXISTS</span> <span style="color:#f92672">`</span>player<span style="color:#f92672">`</span>;
<span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#f92672">`</span>player<span style="color:#f92672">`</span>  (
  <span style="color:#f92672">`</span>player_id<span style="color:#f92672">`</span> int(<span style="color:#ae81ff">11</span>) <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span> AUTO_INCREMENT,
  <span style="color:#f92672">`</span>team_id<span style="color:#f92672">`</span> int(<span style="color:#ae81ff">11</span>) <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>,
  <span style="color:#f92672">`</span>player_name<span style="color:#f92672">`</span> varchar(<span style="color:#ae81ff">255</span>) CHARACTER <span style="color:#66d9ef">SET</span> utf8 <span style="color:#66d9ef">COLLATE</span> utf8_general_ci <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>,
  <span style="color:#f92672">`</span>height<span style="color:#f92672">`</span> float(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">NULL</span> <span style="color:#66d9ef">DEFAULT</span> <span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">00</span>,
  <span style="color:#66d9ef">PRIMARY</span> <span style="color:#66d9ef">KEY</span> (<span style="color:#f92672">`</span>player_id<span style="color:#f92672">`</span>) <span style="color:#66d9ef">USING</span> BTREE,
  <span style="color:#66d9ef">UNIQUE</span> <span style="color:#66d9ef">INDEX</span> <span style="color:#f92672">`</span>player_name<span style="color:#f92672">`</span>(<span style="color:#f92672">`</span>player_name<span style="color:#f92672">`</span>) <span style="color:#66d9ef">USING</span> BTREE
) ENGINE <span style="color:#f92672">=</span> InnoDB CHARACTER <span style="color:#66d9ef">SET</span> <span style="color:#f92672">=</span> utf8 <span style="color:#66d9ef">COLLATE</span> <span style="color:#f92672">=</span> utf8_general_ci ROW_FORMAT <span style="color:#f92672">=</span> <span style="color:#66d9ef">Dynamic</span>;
</code></pre></div><p><strong>为了避免它们的名称与 MySQL 保留字段相同，对数据表和字段名称都加上了反引号</strong></p>
<p>player_name 字段的字符集是 utf8，排序规则是<code>utf8_general_ci</code>，代表对大小写不敏感，如果设置为<code>utf8_bin</code>，代表对大小写敏感</p>
<p>player_id 设置为了主键，因此在 DDL 中使用<code>PRIMARY KEY</code>进行规定，同时索引方法采用 BTREE</p>
<blockquote>
<p>设置主键是为了确定唯一性，当一个字段无法确定唯一性的时候，就需要采用联合主键的方式（也就是用多个字段来定义一个主键）。联合主键中的字段越多，占用的索引空间越大，不仅会加大理解难度，还会增加运行时间和索引空间，因此联合主键的字段个数越少越好。</p>
</blockquote>
<p>对 player_name 字段进行索引，在设置字段索引时，我们可以设置为<code>UNIQUE INDEX</code>（唯一索引），也可以设置为其他索引方式，比如<code>NORMAL INDEX</code>（普通索引）；唯一索引和普通索引的区别在于它对字段进行了唯一性的约束。在索引方式上，你可以选择<code>BTREE</code>或者<code>HASH</code>，这里采用了<code>BTREE</code>方法进行索引</p>
<h3 id="修改table">修改TABLE</h3>
<ol>
<li>
<p>添加一个 age 字段，类型为<code>int(11)</code></p>
<blockquote>
<p>ALTER TABLE player ADD (age int(11));</p>
</blockquote>
<!-- raw HTML omitted -->
</li>
<li>
<p>修改字段名，将 age 字段改成<code>player_age</code></p>
<blockquote>
<p>ALTER TABLE player RENAME COLUMN age to player_age;</p>
</blockquote>
</li>
<li>
<p>修改字段的数据类型，将<code>player_age</code>的数据类型设置为<code>float(3,1)</code></p>
<blockquote>
<p>ALTER TABLE palyer MODIFY (player_age float(3,1));</p>
</blockquote>
</li>
<li>
<p>删除刚才添加的<code>player_age</code>字段</p>
<blockquote>
<p>ALTER TABLE player DROP COLUMN player_age;</p>
</blockquote>
</li>
</ol>
<h3 id="常见约束">常见约束</h3>
<ol>
<li>
<p>主键约束：</p>
<p>主键起的作用是唯一标识一条记录，不能重复，不能为空，即 UNIQUE+NOT NULL。一个数据表的主键只能有一个。主键可以是一个字段，也可以由多个字段复合组成。</p>
</li>
<li>
<p>外键约束：</p>
<p>外键确保了表与表之间引用的完整性。一个表中的外键对应另一张表的主键。外键可以是重复的，也可以为空。</p>
<blockquote>
<p>外键本身是为了强一致性，强调 正确性&gt;性能，在数据库层面保证了数据的完整性和一致性。不过也可以不使用外键，可以在业务层进行实现。但这样会让业务逻辑与数据有一定的耦合性。也就是业务逻辑和数据必须同时修改。</p>
</blockquote>
</li>
<li>
<p>唯一性约束、NOT NULL 约束、DEFAULT等</p>
</li>
<li>
<p>CHECK 约束</p>
<p>用来检查特定字段取值范围的有效性，CHECK 约束的结果不能为 FALSE，比如我们可以对身高 height 的数值进行 CHECK 约束，必须≥0，且＜3，即<code>CHECK(height&gt;=0 AND height&lt;3)</code></p>
</li>
</ol>
<h1 id="select">SELECT</h1>
<h2 id="查询语法">查询语法</h2>
<h3 id="1查询列">1.查询列</h3>
<ol>
<li>
<p>查询列</p>
<blockquote>
<p>SELECT name FROM heros</p>
</blockquote>
</li>
<li>
<p>查询多个列</p>
<blockquote>
<p>SELECT name, hp_max, mp_max, attack_max FROM heros</p>
</blockquote>
</li>
<li>
<p>检索出所有列</p>
<blockquote>
<p>SELECT * FROM heros</p>
</blockquote>
</li>
</ol>
<h3 id="2起别名as">2.起别名(AS)</h3>
<p>起别名(AS)</p>
<blockquote>
<p>SELECT name AS n, hp_max AS hm, mp_max AS mm, attack_m AS am FROM heros</p>
</blockquote>
<p>也可以对表取别名，在多表查询的时候会用到</p>
<p><del>AS</del>在大多数情况下也可以省略不写，例如</p>
<blockquote>
<p>SELECT deptno, name <del>AS</del> deptname from dept; （这样显示的列名由dname变成了deptname）</p>
</blockquote>
<p>查询常数</p>
<p>对 heros 数据表中的英雄名进行查询，同时增加一列字段<code>platform</code>，这个字段固定值为“王者荣耀”，可以这样写：</p>
<blockquote>
<p>SQL：SELECT &lsquo;王者荣耀&rsquo; as platform, name FROM heros</p>
</blockquote>
<p>在这个 SQL 语句中，我们虚构了一个<code>platform</code>字段，并且把它设置为固定值“王者荣耀”</p>
<!-- raw HTML omitted -->
<p><img src="SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4.assets/image-20230518162538527.png" alt=""></p>
<p>需要说明的是，<strong>如果常数是个字符串，那么使用单引号（‘’）就非常重要了</strong>，比如‘王者荣耀’。单引号说明引号中的字符串是个常数，否则 SQL 会把王者荣耀当成列名进行查询，但实际上数据表里没有这个列名，就会引起错误。<strong>如果常数是英文字母，比如<code>'WZRY'</code>也需要加引号</strong>。如果常数是个数字，就可以直接写数字，不需要单引号，比如：</p>
<blockquote>
<p>SQL：SELECT 123 as platform, name FROM heros</p>
</blockquote>
<h3 id="3去除重复行distinct">3.去除重复行(DISTINCT)</h3>
<p>关于单个表的 SELECT 查询，还有一个非常实用的操作，就是从结果中去掉重复的行。使用的关键字是 DISTINCT。</p>
<blockquote>
<p>SQL：SELECT DISTINCT attack_range FROM heros</p>
</blockquote>
<figure><img src="SQL%e5%bf%85%e7%9f%a5%e5%bf%85%e4%bc%9a-%e6%9e%81%e5%ae%a2%e6%97%b6%e9%97%b4.assets/image-20230518162743282-4476221.png" width="40%"/>
</figure>

<p>加上name的去重查询</p>
<blockquote>
<p>SELECT DISTINCT attack_range, name FROM heros</p>
</blockquote>
<p><img src="SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4.assets/image-20230518162854810-4476225.png" alt=""></p>
<ul>
<li>DISTINCT 需要放在所有查询列之前</li>
<li>DISTINCT 其实是对后面所有列名的组合进行去重</li>
</ul>
<h2 id="排序检索数据order-by">排序检索数据(ORDER BY)</h2>
<p>ORDER BY</p>
<ol>
<li>排序的列名：ORDER BY后面可以有一个或多个列名，如果是多个列名进行排序，会按照后面第一个列先进行排序，当第一列值相同的时候，再按照第二列进行排序，以此类推</li>
<li>排序的顺序：ORDER BY后面可以注明排序规则，ASC代表递增排序，DESC代表递减排序，<strong>默认是按照ASC顺序</strong></li>
<li>非选择排序：即使在 SELECT 后面没有这个列名，你同样可以放到 ORDER BY 后面进行排序</li>
<li>位置：ORDER BY通常位于SELECT语句的最后一条子句</li>
</ol>
<p>eg：</p>
<p>显示英雄名称及最大生命值，按照最大生命值从高到低的方式进行排序：</p>
<blockquote>
<p>SQL：SELECT name, hp_max FROM heros ORDER BY hp_max DESC</p>
</blockquote>
<p>想要显示英雄名称及最大生命值，按照第一排序最大法力从低到高，当最大法力值相等的时候则按照第二排序进行，即最大生命值从高到低的方式进行排序：</p>
<blockquote>
<p>SQL：SELECT name, hp_max FROM heros ORDER BY mp_max, hp_max DESC</p>
</blockquote>
<h2 id="约束返回结果的数量limit">约束返回结果的数量(LIMIT)</h2>
<blockquote>
<p>SQL：SELECT name, hp_max FROM heros ORDER BY hp_max DESC LIMIT 5</p>
</blockquote>
<p>注意：</p>
<p>约束返回结果的数量，在不同的 DBMS 中使用的关键字可能不同。在 MySQL、PostgreSQL、MariaDB 和 SQLite 中使用 LIMIT 关键字，而且需要放到 SELECT 语句的最后面。如果是 SQL Server 和 Access，需要使用 TOP 关键字，比如：</p>
<blockquote>
<p>SQL：SELECT TOP 5 name, hp_max FROM heros ORDER BY hp_max DESC</p>
</blockquote>
<h3 id="limit更多内容">LIMIT更多内容</h3>
<ul>
<li>
<p>检索记录行6-15</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> <span style="color:#66d9ef">table_name</span> <span style="color:#66d9ef">LIMIT</span> <span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">10</span>
</code></pre></div></li>
<li>
<p>为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定rows参数为-1</p>
<p>例如：检索记录行 20 到末尾</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> <span style="color:#66d9ef">table_name</span> <span style="color:#66d9ef">LIMIT</span> <span style="color:#ae81ff">19</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</code></pre></div></li>
<li>
<p>检索前5条记录</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> <span style="color:#66d9ef">table_name</span> <span style="color:#66d9ef">LIMIT</span> <span style="color:#ae81ff">5</span>
</code></pre></div></li>
</ul>
<h2 id="select的执行顺序">SELECT的执行顺序</h2>
<ol>
<li>关键字的顺序不能颠倒</li>
</ol>
<blockquote>
<p>SELECT &hellip; FROM &hellip; WHERE &hellip; GROUP BY &hellip; HAVING &hellip; ORDER BY &hellip;</p>
</blockquote>
<ol start="2">
<li>SELECT语句的执行顺序（在MySQL和Oracle中，SELECT执行顺序基本相同）</li>
</ol>
<blockquote>
<p>FROM &gt; WHERE &gt; GROUP BY &gt; HAVING &gt; SELECT的字段 &gt; DISTINCT &gt; ORDER BY &gt; LIMIT</p>
</blockquote>
<p>eg:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">DISTINCT</span> player_id, player_name, <span style="color:#66d9ef">count</span>(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">as</span> num <span style="color:#f92672">#</span> <span style="color:#960050;background-color:#1e0010">顺序</span> <span style="color:#ae81ff">5</span>
<span style="color:#66d9ef">FROM</span> player <span style="color:#66d9ef">JOIN</span> team <span style="color:#66d9ef">ON</span> player.team_id <span style="color:#f92672">=</span> team.team_id <span style="color:#f92672">#</span> <span style="color:#960050;background-color:#1e0010">顺序</span> <span style="color:#ae81ff">1</span>
<span style="color:#66d9ef">WHERE</span> height <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>.<span style="color:#ae81ff">80</span> <span style="color:#f92672">#</span> <span style="color:#960050;background-color:#1e0010">顺序</span> <span style="color:#ae81ff">2</span>
<span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span> player.team_id <span style="color:#f92672">#</span> <span style="color:#960050;background-color:#1e0010">顺序</span> <span style="color:#ae81ff">3</span>
<span style="color:#66d9ef">HAVING</span> num <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">#</span> <span style="color:#960050;background-color:#1e0010">顺序</span> <span style="color:#ae81ff">4</span>
<span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span> num <span style="color:#66d9ef">DESC</span> <span style="color:#f92672">#</span> <span style="color:#960050;background-color:#1e0010">顺序</span> <span style="color:#ae81ff">6</span>
<span style="color:#66d9ef">LIMIT</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">#</span> <span style="color:#960050;background-color:#1e0010">顺序</span> <span style="color:#ae81ff">7</span>
</code></pre></div><p>在SELECT语句执行这些步骤的时候，每个步骤都会产生一个虚拟表，然后将这个虚拟表传入下一个步骤中作为输入。（执行过程对用户不可见）</p>
<p>详细分析：</p>
<p>首先进行条件筛选部分</p>
<ol>
<li>
<p>SELECT先执行FROM这一步，在这个阶段，如果是多张表联查，还会经历</p>
<ul>
<li>先通过CROSS JOIN求笛卡尔积，相当于得到虚拟表vt（virtual table）1-1</li>
<li>通过ON进行筛选，在虚拟表vt1-1的基础上进行筛选，得到虚拟表vt1-2</li>
<li>添加外部行。如果使用的是左连接、右连接或者全连接，就会涉及到外部行，也就是在虚拟表vt1-2的基础上增加外部行，得到虚拟表vt1-3</li>
</ul>
<p>如果我们操作的是两张以上的表，还会重复上面的步骤，直到所有表都被处理完为止，这个过程得到是我们的原始数据</p>
</li>
<li>
<p>拿到了查询数据表的原始数据，也就是最终的虚拟表vt1，就可以在此基础上再进行WHERE阶段，在这个阶段中，会根据vt1表的结果进行筛选过滤，得到虚拟表vt2</p>
</li>
<li>
<p>然后进入第三步和第四步，也就是GROUP和HAVING阶段，在这个阶段中，实际上是在虚拟表vt2的基础上进行分组和分组过滤，得到中间的虚拟表vt3和vt4</p>
</li>
</ol>
<p>当完成了条件筛选部分之后，就可以筛选表中提取的字段，也就是进入到SELECT和DISTINCT阶段</p>
<ol>
<li>首先在SELECT阶段会提取想要的字段，然后在DISTINCT阶段过滤掉重复的行，分别得到vt5-1和vt5-2</li>
<li>当提取了想要的字段数据后，就可以按照指定的字段进行排序，也就是ORDER BY阶段，得到虚拟表vt6</li>
<li>最后在vt6的基础上，取出指定行的记录，也就是LIMIT阶段，得到最终的结果，对应的是虚拟表vt7</li>
</ol>
<h2 id="过滤where">过滤（WHERE）</h2>
<h3 id="1比较运算符">1.比较运算符</h3>
<p><img src="SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4.assets/image-20230519140719141.png" alt=""></p>
<p>取决于DBMS是否支持，如<strong>Access 不支持（!=），不等于应该使用（&lt;&gt;）。在 MySQL 中，不支持（!&gt;）（!&lt;）等</strong></p>
<p>eg：</p>
<blockquote>
<p>SQL：SELECT name, hp_max FROM heros WHERE hp_max BETWEEN 5399 AND 6811</p>
</blockquote>
<p>空值检查</p>
<blockquote>
<p>SQL：SELECT name, hp_max FROM heros WHERE hp_max IS NULL</p>
</blockquote>
<h3 id="2逻辑运算符">2.逻辑运算符</h3>
<p><img src="SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4.assets/image-20230519141359747.png" alt=""></p>
<p>eg:</p>
<ul>
<li>AND</li>
</ul>
<ol>
<li>筛选最大生命值大于 6000，最大法力大于 1700 的英雄，然后按照最大生命值和最大法力值之和从高到低进行排序</li>
</ol>
<blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SQL</span><span style="color:#960050;background-color:#1e0010">：</span><span style="color:#66d9ef">SELECT</span> name, hp_max, mp_max <span style="color:#66d9ef">FROM</span> heros <span style="color:#66d9ef">WHERE</span> hp_max <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">6000</span> <span style="color:#66d9ef">AND</span> mp_max <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1700</span> <span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span> (hp_max<span style="color:#f92672">+</span>mp_max) <span style="color:#66d9ef">DESC</span>
</code></pre></div></blockquote>
<ul>
<li>AND + OR</li>
</ul>
<ol start="2">
<li>如果 AND 和 OR 同时存在 WHERE 子句中会是怎样的呢？假设我们想要查询最大生命值加最大法力值大于 8000 的英雄，或者最大生命值大于 6000 并且最大法力值大于 1700 的英雄。</li>
</ol>
<blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SQL</span><span style="color:#960050;background-color:#1e0010">：</span><span style="color:#66d9ef">SELECT</span> name, hp_max, mp_max <span style="color:#66d9ef">FROM</span> heros <span style="color:#66d9ef">WHERE</span> (hp_max<span style="color:#f92672">+</span>mp_max) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">8000</span> <span style="color:#66d9ef">OR</span> hp_max <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">6000</span> <span style="color:#66d9ef">AND</span> mp_max <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1700</span> <span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span> (hp_max<span style="color:#f92672">+</span>mp_max) <span style="color:#66d9ef">DESC</span>
</code></pre></div></blockquote>
<p>结果发现，这次的查询多了一些，因为放宽了条件，允许最大生命值+最大法力值大于8000的英雄显示出来，⚠️，当WHERE子句中同时存在OR和AND的时候，AND执行的优先级会更高，也就是说<strong>SQL会优先处理AND操作符，然后再处理OR操作符</strong></p>
<ul>
<li>AND + OR + （）</li>
</ul>
<ol start="3">
<li>如果对这条查询语句OR两边的条件增加一个括号</li>
</ol>
<blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SQL</span><span style="color:#960050;background-color:#1e0010">：</span><span style="color:#66d9ef">SELECT</span> name, hp_max, mp_max <span style="color:#66d9ef">FROM</span> heros <span style="color:#66d9ef">WHERE</span> ((hp_max<span style="color:#f92672">+</span>mp_max) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">8000</span> <span style="color:#66d9ef">OR</span> hp_max <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">6000</span>) <span style="color:#66d9ef">AND</span> mp_max <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1700</span> <span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span> (hp_max<span style="color:#f92672">+</span>mp_max) <span style="color:#66d9ef">DESC</span>
</code></pre></div></blockquote>
<p>当WHERE子句中同时出现AND和OR操作符，执行的先后顺序为：一般来说（）优先级最高，其次是AND，然后是OR</p>
<ul>
<li>AND + OR + IN + NOT</li>
</ul>
<ol start="4">
<li>查询主要定位或者次要定位是法师或者射手的英雄，同时英雄的上线时间不再2016-01-01到2017-01-01之间</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SQL</span><span style="color:#960050;background-color:#1e0010">：</span>
<span style="color:#66d9ef">SELECT</span> name, role_main, role_assist, hp_max, mp_max, birthdate
<span style="color:#66d9ef">FROM</span> heros 
<span style="color:#66d9ef">WHERE</span> (role_main <span style="color:#66d9ef">IN</span> (<span style="color:#e6db74">&#39;法师&#39;</span>, <span style="color:#e6db74">&#39;射手&#39;</span>) <span style="color:#66d9ef">OR</span> role_assist <span style="color:#66d9ef">IN</span> (<span style="color:#e6db74">&#39;法师&#39;</span>, <span style="color:#e6db74">&#39;射手&#39;</span>)) 
<span style="color:#66d9ef">AND</span> DATE(birthdate) <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">BETWEEN</span> <span style="color:#e6db74">&#39;2016-01-01&#39;</span> <span style="color:#66d9ef">AND</span> <span style="color:#e6db74">&#39;2017-01-01&#39;</span>
<span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span> (hp_max <span style="color:#f92672">+</span> mp_max) <span style="color:#66d9ef">DESC</span>
</code></pre></div><h3 id="3通配符like">3.通配符（LIKE）</h3>
<p>通配符就是我们用来匹配值的一部分的特殊字符。这里我们需要使用到 LIKE 操作符。</p>
<p>如果我们想要匹配任意字符串出现的任意次数，需要使用（%）通配符。比如我们想要查找英雄名中包含“太”字的英雄都有哪些：</p>
<blockquote>
<p>SQL：SELECT name FROM heros WHERE name LIKE &lsquo;% 太 %&rsquo;</p>
</blockquote>
<p>可以查询到有两条数据：东皇太一和太乙真人</p>
<p>⚠️不同DBMS对通配符的定义不同，在Access中使用的是（*）而不是（%）。另外关于字符串的搜索可能是需要区分大小写的，比如‘liu%’就不能匹配‘LIUBEI'。具体是否区分大小写还需要考虑不同的DBMS以及它们的配置。</p>
<p>如果想要匹配单个字符，就需要使用下划线（_）通配符。（%）和（ _ ）区别在于，前者代表一个或多个字符，后者只代表一个字符，比如想要查找英雄名除了第一个字以外，包含“太”字的英雄有哪些</p>
<blockquote>
<p>SQL：SELECT name FROM heros WHERE name LIKE &lsquo;_% 太 %&rsquo;</p>
</blockquote>
<p>因为太乙真人的太是第一个字符，而<code>_%太%</code>中的太不是在第一个字符，所以匹配不到“太乙真人”，只可以匹配上“东皇太一”。</p>
<p>同样需要说明的是，在 Access 中使用（?）来代替（<code>_</code>），而且在 DB2 中是不支持通配符（<code>_</code>）的，因此你需要在使用的时候查阅相关的 DBMS 文档。</p>
<p>你能看出来通配符还是很有用的，尤其是在进行字符串匹配的时候。不过在实际操作过程中，我还是建议你尽量少用通配符，因为它需要消耗数据库更长的时间来进行匹配。即使你对 LIKE 检索的字段进行了索引，索引的价值也可能会失效。如果要让索引生效，那么 LIKE 后面就不能以（%）开头，比如使用<code>LIKE '%太%'</code>或<code>LIKE '%太'</code>的时候就会对全表进行扫描。如果使用<code>LIKE '太%'</code>，同时检索的字段进行了索引的时候，则不会进行全表扫描。</p>
<h3 id="练习">练习</h3>
<p>编写 SQL 语句，对英雄名称、主要定位、次要定位、最大生命和最大法力进行查询，筛选条件为：主要定位是坦克或者战士，并且次要定位不为空，同时满足最大生命值大于 8000 或者最大法力小于 1500 的英雄，并且按照最大生命和最大法力之和从高到底的顺序进行排序。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> name, role_main, role_asist, heap_max, mp_max <span style="color:#66d9ef">FROM</span> heros <span style="color:#66d9ef">WHERE</span> role_main <span style="color:#66d9ef">IN</span> (<span style="color:#e6db74">&#39;坦克&#39;</span> , <span style="color:#e6db74">&#39;战士&#39;</span>) <span style="color:#66d9ef">AND</span> role_asist <span style="color:#66d9ef">IS</span> <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span> <span style="color:#66d9ef">AND</span> (heap_max <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">8000</span> <span style="color:#66d9ef">OR</span> mp_max <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1500</span>) <span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span> (heap_max <span style="color:#f92672">+</span> mp_max) <span style="color:#66d9ef">DESC</span>.
</code></pre></div><h2 id="sql函数">SQL函数</h2>
<h3 id="1-算数函数">1. 算数函数</h3>
<p><img src="SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4.assets/image-20230522122152775.png" alt=""></p>
<h3 id="2字符串函数">2.字符串函数</h3>
<p><img src="SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4.assets/image-20230522122303298.png" alt=""></p>
<h3 id="3日期函数">3.日期函数</h3>
<p><img src="SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4.assets/image-20230522122403236.png" alt=""></p>
<p><code>SELECT DATE('2019-04-01 12:00:05')</code>，运行结果为 2019-04-01。</p>
<p>这里需要注意的是，DATE 日期格式必须是 yyyy-mm-dd 的形式。如果要进行日期比较，就要使用 DATE 函数，不要直接使用日期与字符串进行比较。</p>
<h3 id="4转换函数">4.转换函数</h3>
<p><img src="SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4.assets/image-20230522122559551.png" alt=""></p>
<p>这两个函数不像其他函数，看一眼函数名就知道代表什么、如何使用。下面举了这两个函数的例子，你需要自己运行下：</p>
<p><code>SELECT CAST(123.123 AS INT)</code>，运行结果会报错。</p>
<p><code>SELECT CAST(123.123 AS DECIMAL(8,2))</code>，运行结果为 123.12。</p>
<p><code>SELECT COALESCE(null,1,2)</code>，运行结果为 1。</p>
<p>CAST 函数在转换数据类型的时候，不会四舍五入，如果原数值有小数，那么转换为整数类型的时候就会报错。不过你可以指定转化的小数类型，在 MySQL 和 SQL Server 中，你可以用<code>DECIMAL(a,b)</code>来指定，其中 a 代表整数部分和小数部分加起来最大的位数，b 代表小数位数，比如<code>DECIMAL(8,2)</code>代表的是精度为 8 位（整数加小数位数最多为 8 位），小数位数为 2 位的数据类型。所以<code>SELECT CAST(123.123 AS DECIMAL(8,2))</code>的转换结果为 123.12。</p>
<p>示例：</p>
<p>首先显示英雄以及他的物攻成长，对应的字段为attack_growth, 我们让这个字段精确到小数点后一位，需要使用的是算术函数里的 ROUND 函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> name, ROUND(attack_growth,<span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">FROM</span> heros
</code></pre></div><p>代码中，<code>ROUND(attack_growth,1)</code>中的<code>attack_growth</code>代表想要处理的数据，“1”代表四舍五入的位数，也就是我们这里需要精确到的位数。</p>
<p>运行结果为：</p>
<p><img src="SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4.assets/image-20230522123202494.png" alt=""></p>
<p>假设想要显示英雄最大生命值的最大值，就需要用到MAX函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SQL</span><span style="color:#960050;background-color:#1e0010">：</span>
<span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">MAX</span>(hp_max) <span style="color:#66d9ef">FROM</span> heros
</code></pre></div><p>假如我们想要知道最大生命值最大的是哪个英雄，以及对应的数值，就需要分成两个步骤来处理：首先找到英雄的最大生命值的最大值，即<code>SELECT MAX(hp_max) FROM heros</code>，然后再筛选最大生命值等于这个最大值的英雄，如下所示。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SQL</span><span style="color:#960050;background-color:#1e0010">：</span>
<span style="color:#66d9ef">SELECT</span> name, hp_max <span style="color:#66d9ef">FROM</span> heros <span style="color:#66d9ef">WHERE</span> hp_max <span style="color:#f92672">=</span> (<span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">MAX</span>(hp_max) <span style="color:#66d9ef">FROM</span> heros)
</code></pre></div><p>假如想要提取英雄上线日期（对应字段 birthdate）的年份，只显示有上线日期的英雄即可（有些英雄没有上线日期的数据，不需要显示），这里我们需要使用 EXTRACT 函数，提取某一个时间元素。所以我们需要筛选上线日期不为空的英雄，即<code>WHERE birthdate is not null</code>，然后再显示他们的名字和上线日期的年份，即：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SQL</span><span style="color:#960050;background-color:#1e0010">：</span>
<span style="color:#66d9ef">SELECT</span> name, <span style="color:#66d9ef">EXTRACT</span>(<span style="color:#66d9ef">YEAR</span> <span style="color:#66d9ef">FROM</span> birthdate) <span style="color:#66d9ef">AS</span> birthdate <span style="color:#66d9ef">FROM</span> heros <span style="color:#66d9ef">WHERE</span> birthdate <span style="color:#66d9ef">is</span> <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>
</code></pre></div><p>或者使用如下形式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SQL</span>:
<span style="color:#66d9ef">SELECT</span> name, <span style="color:#66d9ef">YEAR</span>(birthdate) <span style="color:#66d9ef">AS</span> birthdate <span style="color:#66d9ef">FROM</span> heros <span style="color:#66d9ef">WHERE</span> birthdate <span style="color:#66d9ef">is</span> <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>
</code></pre></div><p>假设我们需要找出在 2016 年 10 月 1 日之后上线的所有英雄。这里我们可以采用 DATE 函数来判断 birthdate 的日期是否大于 2016-10-01，即<code>WHERE DATE(birthdate)&gt;'2016-10-01'</code>，然后再显示符合要求的全部字段信息，即：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> heros <span style="color:#66d9ef">WHERE</span> DATE(birthdate)<span style="color:#f92672">&gt;</span><span style="color:#e6db74">&#39;2016-10-01&#39;</span>
</code></pre></div><p>需要注意的是下面这种写法是不安全的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> heros <span style="color:#66d9ef">WHERE</span> birthdate<span style="color:#f92672">&gt;</span><span style="color:#e6db74">&#39;2016-10-01&#39;</span>
</code></pre></div><p>因为很多时候你无法确认 birthdate 的数据类型是字符串，还是 datetime 类型，如果你想对日期部分进行比较，那么使用<code>DATE(birthdate)</code>来进行比较是更安全的。</p>
<p>假设我们需要知道在 2016 年 10 月 1 日之后上线英雄的平均最大生命值、平均最大法力和最高物攻最大值。同样我们需要先筛选日期条件，即<code>WHERE DATE(birthdate)&gt;'2016-10-01'</code>，然后再选择<code>AVG(hp_max), AVG(mp_max), MAX(attack_max)</code>字段进行显示。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SQL</span><span style="color:#960050;background-color:#1e0010">：</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">AVG</span>(hp_max), <span style="color:#66d9ef">AVG</span>(mp_max), <span style="color:#66d9ef">MAX</span>(attack_max) <span style="color:#66d9ef">FROM</span> heros <span style="color:#66d9ef">WHERE</span> DATE(birthdate)<span style="color:#f92672">&gt;</span><span style="color:#e6db74">&#39;2016-10-01&#39;</span>
</code></pre></div><h3 id="规范">规范</h3>
<ol>
<li>关键字和函数名称全部大写；</li>
<li>数据库名、表名、字段名称全部小写；</li>
<li>SQL 语句必须以分号结尾。</li>
</ol>
<p>虽然关键字和函数名称在 SQL 中不区分大小写，也就是如果小写的话同样可以执行，但是数据库名、表名和字段名在 Linux MySQL 环境下是区分大小写的，因此建议你统一这些字段的命名规则，比如全部采用小写的方式。同时将关键词和函数名称全部大写，以便于区分数据库名、表名、字段名。</p>
<h3 id="练习-1">练习</h3>
<p>计算英雄的最大生命平均值；</p>
<blockquote>
<p>SELECT AVG(max_heap) AS avg_max FROM heros;</p>
</blockquote>
<p>显示出所有在 2017 年之前上线的英雄，如果英雄没有统计上线日期则不显示。</p>
<blockquote>
<p>SELECT name FROM heros WHERE YEAR(birthday) &lt; 2017 AND birthday IS NOT NULL;</p>
</blockquote>
<h3 id="5聚集函数countmaxminsumavg">5.聚集函数(COUNT、MAX、MIN、SUM、AVG)</h3>
<p>SQL中的聚集函数一共有5个：COUNT()、MAX()、MIN()、SUM()、AVG()</p>
<p>Eg:</p>
<ol>
<li>
<p>查询最大生命值大于 6000 的英雄数量</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">COUNT</span>(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">FROM</span> heros <span style="color:#66d9ef">WHERE</span> hp_max <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">6000</span>
</code></pre></div></li>
<li>
<p>查询最大生命值大于 6000，且有次要定位的英雄数量，需要使用 COUNT 函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">COUNT</span>(role_assist) <span style="color:#66d9ef">FROM</span> heros <span style="color:#66d9ef">WHERE</span> hp_max <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">6000</span>
</code></pre></div><p>⚠️有些英雄没有次要定位，即 role_assist 为 NULL，这时<code>COUNT(role_assist)</code>会忽略值为 NULL 的数据行，而 COUNT(*) 只是统计数据行数，不管某个字段是否为 NULL。</p>
</li>
<li>
<p>查询射手（主要定位或者次要定位是射手）的最大生命值的最大值是多少，需要使用 MAX 函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">MAX</span>(hp_max) <span style="color:#66d9ef">FROM</span> heros <span style="color:#66d9ef">WHERE</span> role_main <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;射手&#39;</span> <span style="color:#66d9ef">or</span> role_assist <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;射手&#39;</span>
</code></pre></div></li>
<li>
<p>想知道射手（主要定位或者次要定位是射手）的英雄数、平均最大生命值、法力最大值的最大值、攻击最大值的最小值，以及这些英雄总的防御最大值等汇总数据</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">COUNT</span>(<span style="color:#f92672">*</span>), <span style="color:#66d9ef">AVG</span>(hp_max), <span style="color:#66d9ef">MAX</span>(mp_max), <span style="color:#66d9ef">MIN</span>(attack_max), <span style="color:#66d9ef">SUM</span>(defense_max) <span style="color:#66d9ef">FROM</span> heros <span style="color:#66d9ef">WHERE</span> role_main <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;射手&#39;</span> <span style="color:#66d9ef">or</span> role_assist <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;射手&#39;</span>
</code></pre></div><p>⚠️需要说明的是 AVG、MAX、MIN 等聚集函数会自动忽略值为 NULL 的数据行，MAX 和 MIN 函数也可以用于字符串类型数据的统计，如果是英文字母，则按照 A—Z 的顺序排列，越往后，数值越大。如果是汉字则按照全拼拼音进行排列</p>
</li>
<li>
<p>查询不同的生命最大值的英雄数量是多少</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">COUNT</span>(<span style="color:#66d9ef">DISTINCT</span> hp_max) <span style="color:#66d9ef">FROM</span> heros
</code></pre></div></li>
<li>
<p>统计不同生命最大值英雄的平均生命最大值，保留小数点后两位。</p>
<p>首先需要取不同生命最大值，即<code>DISTINCT hp_max</code>，然后针对它们取平均值，即<code>AVG(DISTINCT hp_max)</code>，最后再针对这个值保留小数点两位，也就是<code>ROUND(AVG(DISTINCT hp_max), 2)</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> ROUND(<span style="color:#66d9ef">AVG</span>(<span style="color:#66d9ef">DISTINCT</span> hp_max), <span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">FROM</span> heros
</code></pre></div></li>
</ol>
<h4 id="分组group-by">分组(GROUP BY)</h4>
<p>在做统计的时候，可能需要先对数据按照不同的数值进行分组，然后对这些分好的组进行聚集统计。对数据进行分组，需要使用 GROUP BY 子句。</p>
<p>比如我们想按照英雄的主要定位进行分组，并统计每组的英雄数量。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">COUNT</span>(<span style="color:#f92672">*</span>), role_main <span style="color:#66d9ef">FROM</span> heros <span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span> role_main
</code></pre></div><p>运行结果：</p>
<p><img src="SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4.assets/image-20230522213849933.png" alt=""></p>
<p>比如我们想要对英雄按照次要定位进行分组，并统计每组英雄的数量</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">COUNT</span>(<span style="color:#f92672">*</span>), role_assist <span style="color:#66d9ef">FROM</span> heros <span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span> role_assist
</code></pre></div><p>运行结果：（6 条记录）</p>
<p><img src="SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4.assets/image-20230522214020070.png" alt=""></p>
<p>你能看出如果字段为 NULL，也会被列为一个分组。在这个查询统计中，次要定位为 NULL，即只有一个主要定位的英雄是 40 个。</p>
<p>我们也可以使用多个字段进行分组，这就相当于把这些字段可能出现的所有的取值情况都进行分组。</p>
<p>比如，我们想要按照英雄的主要定位、次要定位进行分组，查看这些英雄的数量，并按照这些分组的英雄数量从高到低进行排序。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">COUNT</span>(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">as</span> num, role_main, role_assist <span style="color:#66d9ef">FROM</span> heros <span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span> role_main, role_assist <span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span> num <span style="color:#66d9ef">DESC</span>
</code></pre></div><p>运行结果：（19 条记录）</p>
<p><img src="SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4.assets/image-20230522214149860.png" alt=""></p>
<p>Tips: 可以发现：<strong>在执行顺序上，SELECT字段在GROUP BY和HAVING之后，不过在SELECT字段之前，已经计算了聚集函数，也就是COUNT(*) as num。聚集函数的计算在GROUP BY之后，HAVING之前。</strong></p>
<h4 id="过滤分组having">过滤分组(HAVING)</h4>
<p>当我们创建出很多分组的时候，有时候就需要对分组进行过滤。你可能首先会想到 WHERE 子句，实际上过滤分组我们使用的是 HAVING。HAVING 的作用和 WHERE 一样，都是起到过滤的作用，只不过 WHERE 是用于数据行，而 HAVING 则作用于分组。</p>
<p>比如我们想要按照英雄的主要定位、次要定位进行分组，并且筛选分组中英雄数量大于 5 的组，最后按照分组中的英雄数量从高到低进行排序。</p>
<p>首先我们需要获取的是英雄的数量、主要定位和次要定位，即<code>SELECT COUNT(*) as num, role_main, role_assist</code>。然后按照英雄的主要定位和次要定位进行分组，即<code>GROUP BY role_main, role_assist</code>，同时我们要对分组中的英雄数量进行筛选，选择大于 5 的分组，即<code>HAVING num &gt; 5</code>，然后按照英雄数量从高到低进行排序，即<code>ORDER BY num DESC</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">COUNT</span>(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">as</span> num, role_main, role_assist <span style="color:#66d9ef">FROM</span> heros <span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span> role_main, role_assist <span style="color:#66d9ef">HAVING</span> num <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">5</span> <span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span> num <span style="color:#66d9ef">DESC</span>
</code></pre></div><p>运行结果：（4 条记录）</p>
<p><img src="SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4.assets/image-20230522214423373.png" alt=""></p>
<p>如果把 HAVING 替换成了 WHERE，SQL 则会报错。<strong>对于分组的筛选，我们一定要用 HAVING</strong>，而不是 WHERE。另外你需要知道的是，<strong>HAVING 支持所有 WHERE 的操作，因此所有需要 WHERE 子句实现的功能，你都可以使用 HAVING 对分组进行筛选</strong>。</p>
<p>Eg:</p>
<p>筛选最大生命值大于 6000 的英雄，按照主要定位、次要定位进行分组，并且显示分组中英雄数量大于 5 的分组，按照数量从高到低进行排序。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">COUNT</span>(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">as</span> num, role_main, role_assist <span style="color:#66d9ef">FROM</span> heros <span style="color:#66d9ef">WHERE</span> hp_max <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">6000</span> <span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span> role_main, role_assist <span style="color:#66d9ef">HAVING</span> num <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">5</span> <span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span> num <span style="color:#66d9ef">DESC</span>
</code></pre></div><p>运行结果：（2 条记录）</p>
<p><img src="SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4.assets/image-20230522214949668.png" alt=""></p>
<p><strong>要记住，在 SELECT 查询中，关键字的顺序是不能颠倒的，它们的顺序是：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> ... <span style="color:#66d9ef">FROM</span> ... <span style="color:#66d9ef">WHERE</span> ... <span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span> ... <span style="color:#66d9ef">HAVING</span> ... <span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span> ...
</code></pre></div><h3 id="练习-2">练习</h3>
<ol>
<li>
<p>筛选最大生命值大于 6000 的英雄，按照主要定位进行分组，选择分组英雄数量大于 5 的分组，按照分组英雄数从高到低进行排序，并显示每个分组的英雄数量、主要定位和平均最大生命值。</p>
<p>分析：最后一句“显示&hellip;“是查询目的，所以先写这个，再按照条件一句句写下来即可</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">COUNT</span>(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">AS</span> num, role_main, <span style="color:#66d9ef">AVG</span>(hp_max) <span style="color:#66d9ef">FROM</span> heros <span style="color:#66d9ef">WHERE</span> hp_max <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">6000</span> <span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span> role_main <span style="color:#66d9ef">HAVING</span> num <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">5</span> <span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span> num <span style="color:#66d9ef">DESC</span>;
</code></pre></div></li>
<li>
<p>筛选最大生命值与最大法力值之和大于 7000 的英雄，按照攻击范围来进行分组，显示分组的英雄数量，以及分组英雄的最大生命值与法力值之和的平均值、最大值和最小值，并按照分组英雄数从高到低进行排序，其中聚集函数的结果包括小数点后两位。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">COUNT</span>(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">AS</span> num, ROUND(<span style="color:#66d9ef">AVG</span>(hp_max <span style="color:#f92672">+</span> mp_max),<span style="color:#ae81ff">2</span>), ROUND(<span style="color:#66d9ef">MAX</span>(hp_max <span style="color:#f92672">+</span> mp_max),<span style="color:#ae81ff">2</span>), ROUND(<span style="color:#66d9ef">MIN</span>(hp_max <span style="color:#f92672">+</span> mp_max),<span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">WHERE</span> (hp_max <span style="color:#f92672">+</span> mp_max) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">7000</span> <span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span> attack_range <span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span> num <span style="color:#66d9ef">DESC</span>
</code></pre></div></li>
</ol>
<h2 id="子查询">子查询</h2>
<h3 id="非关联子查询">非关联子查询</h3>
<p>eg：</p>
<p>以 <a href="https://github.com/cystanford/sql_nba_data">NBA 球员数据表</a>为例，假设我们想要知道哪个球员的身高最高，最高身高是多少，就可以采用子查询的方式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> player_name, height <span style="color:#66d9ef">FROM</span> player <span style="color:#66d9ef">WHERE</span> height <span style="color:#f92672">=</span> (<span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">MAX</span>(height) <span style="color:#66d9ef">FROM</span> player)
</code></pre></div><h3 id="关联子查询">关联子查询</h3>
<p>子查询的执行依赖于外部查询</p>
<p>eg:</p>
<p>查找每个球队中大于平均身高的球员有哪些，并显示他们的球员姓名、身高以及所在球队 ID</p>
<p>首先先统计球队的平均身高，即</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">AVG</span>(height) <span style="color:#66d9ef">FROM</span> player <span style="color:#66d9ef">AS</span> b <span style="color:#66d9ef">WHERE</span> E a.team_id <span style="color:#f92672">=</span> b.team_id
</code></pre></div><p>然后筛选身高大于这个数值的球员姓名、身高和球队ID，即整合结果为</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> player_name, height, team_id <span style="color:#66d9ef">FROM</span> player <span style="color:#66d9ef">AS</span> a <span style="color:#66d9ef">WHERE</span> height <span style="color:#f92672">&gt;</span> (<span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">AVG</span>(height) <span style="color:#66d9ef">FROM</span> player <span style="color:#66d9ef">AS</span> b <span style="color:#66d9ef">WHERE</span> a.team_id <span style="color:#f92672">=</span> b.team_id)
</code></pre></div><p>可以发现：</p>
<p>非关联子查询与主查询的执行无关，只需要执行一次即可，而关联子查询，则需要将主查询的字段值传入子查询中进行关联查询。</p>
<h3 id="exists子查询">EXISTS子查询</h3>
<p>关联子查询通常也会和 EXISTS 一起来使用，EXISTS 子查询用来判断条件是否满足，满足的话为 True，不满足为 False。</p>
<p>eg：</p>
<p>想要看出场过的球员都有哪些，并且显示他们的姓名、球员 ID 和球队 ID。在这个统计中，是否出场是通过 player_score 这张表中的球员出场表现来统计的，如果某个球员在 player_score 中有出场记录则代表他出场过，这里就使用到了 EXISTS 子查询，即<code>EXISTS (SELECT player_id FROM player_score WHERE player.player_id = player_score.player_id)</code>，然后将它作为筛选的条件，实际上也是关联子查询，即：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> player_id, team_id, player_name <span style="color:#66d9ef">FROM</span> player <span style="color:#66d9ef">WHERE</span> <span style="color:#66d9ef">EXISTS</span> (<span style="color:#66d9ef">SELECT</span> player_id <span style="color:#66d9ef">FROM</span> player_score <span style="color:#66d9ef">WHERE</span> player.player_id <span style="color:#f92672">=</span> player_score.player_id)
</code></pre></div><p>同样，我们也可以通过NOT EXISTS查询不存在于表中的信息。</p>
<p>eg：</p>
<p>查询不存在于player_score表中的球员信息，比如主表中的player_id不在子表player_score中，判断语句为NOT EXISTS</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> player_id, team_id, player_name <span style="color:#66d9ef">FROM</span> player <span style="color:#66d9ef">WHERE</span> <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">EXISTS</span> (<span style="color:#66d9ef">SELECT</span> player_id <span style="color:#66d9ef">FROM</span> player_score <span style="color:#66d9ef">WHERE</span> player.player_id <span style="color:#f92672">=</span> player_score.player_id)
</code></pre></div><h3 id="集合比较子查询inanyallsome">集合比较子查询(IN、ANY、ALL、SOME)</h3>
<p>集合比较子查询的作用是与另一个查询结果集进行比较，我们可以在子查询中使用 IN、ANY、ALL 和 SOME 操作符，它们的含义和英文意义一样：</p>
<p><img src="SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4.assets/image-20230523180356132.png" alt=""></p>
<p>还是通过上面那个例子，假设我们想要看出场过的球员都有哪些，可以采用 IN 子查询来进行操作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> player_id, team_id, player_name <span style="color:#66d9ef">FROM</span> player <span style="color:#66d9ef">WHERE</span> player_id <span style="color:#66d9ef">IN</span> (<span style="color:#66d9ef">SELECT</span> player_id <span style="color:#66d9ef">FROM</span> player_score <span style="color:#66d9ef">WHERE</span> player.player_id <span style="color:#f92672">=</span> player_score.player_id)
</code></pre></div><p>你会发现运行结果和上面的是一样的，那么问题来了，既然 IN 和 EXISTS 都可以得到相同的结果，那么我们该使用 IN 还是 EXISTS 呢？</p>
<p>我们可以把这个模式抽象为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> A <span style="color:#66d9ef">WHERE</span> cc <span style="color:#66d9ef">IN</span> (<span style="color:#66d9ef">SELECT</span> cc <span style="color:#66d9ef">FROM</span> B)

<span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> A <span style="color:#66d9ef">WHERE</span> EXIST (<span style="color:#66d9ef">SELECT</span> cc <span style="color:#66d9ef">FROM</span> B <span style="color:#66d9ef">WHERE</span> B.cc<span style="color:#f92672">=</span>A.cc)
</code></pre></div><p>IN表是外边和内表进行hash连接，是先执行子查询；</p>
<p>EXISTS是外表进行循环，然后在内表进行查询。</p>
<p>因此如果外表数据量大，则用IN，如果外表数据量小，则用EXISTS。</p>
<p>IN有一个缺陷是不能判断NULL，因此如果字段存在NULL值，则会出现返回，因此最好使用NOT EXISTS。</p>
<p>了解了 IN 查询后，我们来看下 ANY 和 ALL 子查询。刚才讲到了 ANY 和 ALL 都需要使用比较符，比较符包括了（&gt;）（=）（&lt;）（&gt;=）（&lt;=）和（&lt;&gt;）等。</p>
<p>如果我们想要查询球员表中，比印第安纳步行者（对应的 team_id 为 1002）中任何一个球员身高高的球员的信息，并且输出他们的球员 ID、球员姓名和球员身高，该怎么写呢？首先我们需要找出所有印第安纳步行者队中的球员身高，即<code>SELECT height FROM player WHERE team_id = 1002</code>，然后使用 ANY 子查询即：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> player_id, player_name, height <span style="color:#66d9ef">FROM</span> player <span style="color:#66d9ef">WHERE</span> height <span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">ANY</span> (<span style="color:#66d9ef">SELECT</span> height <span style="color:#66d9ef">FROM</span> player <span style="color:#66d9ef">WHERE</span> team_id <span style="color:#f92672">=</span> <span style="color:#ae81ff">1002</span>)
</code></pre></div><p>同样，如果我们想要知道比印第安纳步行者（对应的 team_id 为 1002）中所有球员身高都高的球员的信息，并且输出球员 ID、球员姓名和球员身高，该怎么写呢？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> player_id, player_name, height <span style="color:#66d9ef">FROM</span> player <span style="color:#66d9ef">WHERE</span> height <span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">ALL</span> (<span style="color:#66d9ef">SELECT</span> height <span style="color:#66d9ef">FROM</span> player <span style="color:#66d9ef">WHERE</span> team_id <span style="color:#f92672">=</span> <span style="color:#ae81ff">1002</span>)
</code></pre></div><p><strong>需要强调的是 ANY、ALL 关键字必须与一个比较操作符一起使用</strong>。因为如果你不使用比较操作符，就起不到集合比较的作用，那么使用 ANY 和 ALL 就没有任何意义。</p>
<h3 id="将子查询作为计算字段">将子查询作为计算字段</h3>
<p>实际上子查询也可以作为主查询的计算字段。</p>
<p>eg:</p>
<p>查询每个球队的球员数，也就是对应 team 这张表，我需要查询相同的 team_id 在 player 这张表中所有的球员数量是多少。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> team_name, (<span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">count</span>(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">FROM</span> player <span style="color:#66d9ef">WHERE</span> player.team_id <span style="color:#f92672">=</span> team.team_id) <span style="color:#66d9ef">AS</span> player_num <span style="color:#66d9ef">FROM</span> team
</code></pre></div><p>运行结果：（3 条记录）</p>
<p><img src="SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4.assets/image-20230523182137343.png" alt=""></p>
<p>你能看到，在 player 表中只有底特律活塞和印第安纳步行者的球员数据，所以它们的 player_num 不为 0，而亚特兰大老鹰的 player_num 等于 0。在查询的时候，我将子查询<code>SELECT count(*) FROM player WHERE player.team_id = team.team_id</code>作为了计算字段，通常我们需要给这个计算字段起一个别名，这里我用的是 player_num，因为子查询的语句比较长，使用别名更容易理解。</p>
<h3 id="练习-3">练习</h3>
<p>编写 SQL 语句，得到场均得分大于 20 的球员。场均得分从 player_score 表中获取，同时你需要输出球员的 ID、球员姓名以及所在球队的 ID 信息。</p>
<p>我写的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> player_id, player_name, team_id
<span style="color:#66d9ef">FROM</span> player
<span style="color:#66d9ef">WHERE</span> player_id <span style="color:#66d9ef">IN</span> (<span style="color:#66d9ef">SELECT</span> player_id <span style="color:#66d9ef">FROM</span> player_score <span style="color:#66d9ef">WHERE</span> score <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">20</span>)
</code></pre></div><p>评论区有人写的：</p>
<ol>
<li>用EXISTS</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> player_name, player_id, team_id 
<span style="color:#66d9ef">FROM</span> player 
<span style="color:#66d9ef">WHERE</span> <span style="color:#66d9ef">EXISTS</span> (<span style="color:#66d9ef">SELECT</span> player_id <span style="color:#66d9ef">FROM</span> player_score <span style="color:#66d9ef">WHERE</span> player.player_id <span style="color:#f92672">=</span> player_score.player_id <span style="color:#66d9ef">AND</span> score <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">20</span>)
</code></pre></div><ol start="2">
<li>用IN</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-SQL" data-lang="SQL"><span style="color:#66d9ef">SELECT</span> player_id, player_name, team_id
<span style="color:#66d9ef">FROM</span> player
<span style="color:#66d9ef">AS</span> a <span style="color:#66d9ef">WHERE</span> a.player_id <span style="color:#66d9ef">IN</span> (<span style="color:#66d9ef">SELECT</span> player_id <span style="color:#66d9ef">FROM</span> player_score <span style="color:#66d9ef">AS</span> b <span style="color:#66d9ef">WHERE</span> a.player_id<span style="color:#f92672">=</span>b.player_id <span style="color:#66d9ef">AND</span> <span style="color:#66d9ef">AVG</span>(b.score) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">20</span>)
</code></pre></div><p>显然，不管怎么说我都没有做判断id一致这个操作</p>
<h1 id="连接">连接</h1>
<h2 id="sql92">SQL92</h2>
<p>5 种连接方式，它们分别是笛卡尔积、等值连接、非等值连接、外连接（左连接、右连接）和自连接</p>
<h3 id="笛卡尔积">笛卡尔积</h3>
<p>笛卡尔乘积是一个数学运算。假设我有两个集合 X 和 Y，那么 X 和 Y 的笛卡尔积就是 X 和 Y 的所有可能组合，也就是第一个对象来自于 X，第二个对象来自于 Y 的所有可能。</p>
<p>两张表的笛卡尔积的结果，这是笛卡尔积的调用方式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> player, team
</code></pre></div><p>笛卡尔积也称为交叉连接，英文是 CROSS JOIN，它的作用就是可以把任意表进行连接，即使这两张表不相关。但我们通常进行连接还是需要筛选的，因此你需要在连接后面加上 WHERE 子句，也就是作为过滤条件对连接数据进行筛选。比如后面要讲到的等值连接。</p>
<h3 id="等值连接">等值连接</h3>
<p>两张表的等值连接就是用两张表中都存在的列进行连接。我们也可以对多张表进行等值连接。</p>
<p>针对 player 表和 team 表都存在 team_id 这一列，我们可以用等值连接进行查询。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> player_id, player.team_id, player_name, height, team_name <span style="color:#66d9ef">FROM</span> player, team <span style="color:#66d9ef">WHERE</span> player.team_id <span style="color:#f92672">=</span> team.team_id
</code></pre></div><p>在进行等值连接的时候，可以使用表的别名，这样会让 SQL 语句更简洁：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> player_id, a.team_id, player_name, height, team_name <span style="color:#66d9ef">FROM</span> player <span style="color:#66d9ef">AS</span> a, team <span style="color:#66d9ef">AS</span> b <span style="color:#66d9ef">WHERE</span> a.team_id <span style="color:#f92672">=</span> b.team_id
</code></pre></div><p>需要注意的是，如果我们使用了表的别名，在查询字段中就只能使用别名进行代替，不能使用原有的表名，比如下面的 SQL 查询就会报错：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> player_id, player.team_id, player_name, height, team_name <span style="color:#66d9ef">FROM</span> player <span style="color:#66d9ef">AS</span> a, team <span style="color:#66d9ef">AS</span> b <span style="color:#66d9ef">WHERE</span> a.team_id <span style="color:#f92672">=</span> b.team_id
</code></pre></div><h3 id="非等值连接">非等值连接</h3>
<p>当我们进行多表查询的时候，如果连接多个表的条件是等号时，就是等值连接，其他的运算符连接就是非等值查询。</p>
<p>如果想要知道每个球员的身高的级别，可以采用非等值连接查询。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> p.player_name, p.height, h.height_level
<span style="color:#66d9ef">FROM</span> player <span style="color:#66d9ef">AS</span> p, height_grades <span style="color:#66d9ef">AS</span> h
<span style="color:#66d9ef">WHERE</span> p.height <span style="color:#66d9ef">BETWEEN</span> h.height_lowest <span style="color:#66d9ef">AND</span> h.height_highest
</code></pre></div><h3 id="外连接">外连接</h3>
<p>除了查询满足条件的记录以外，外连接还可以查询某一方不满足条件的记录。两张表的外连接，会有一张是主表，另一张是从表。如果是多张表的外连接，那么第一张表是主表，即显示全部的行，而第剩下的表则显示对应连接的信息。在 SQL92 中采用（+）代表从表所在的位置，而且在 SQL92 中，只有左外连接和右外连接，没有全外连接。</p>
<ol>
<li>左外连接，就是指左边的表是主表，需要显示左边表的全部行，而右侧的表是从表，（+）表示哪个是从表。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> player, team <span style="color:#66d9ef">where</span> player.team_id <span style="color:#f92672">=</span> team.team_id(<span style="color:#f92672">+</span>)
</code></pre></div><p>相当于 SQL99 中的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> player <span style="color:#66d9ef">LEFT</span> <span style="color:#66d9ef">JOIN</span> team <span style="color:#66d9ef">on</span> player.team_id <span style="color:#f92672">=</span> team.team_id
</code></pre></div><ol start="2">
<li>右外连接，指的就是右边的表是主表，需要显示右边表的全部行，而左侧的表是从表。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> player, team <span style="color:#66d9ef">where</span> player.team_id(<span style="color:#f92672">+</span>) <span style="color:#f92672">=</span> team.team_id
</code></pre></div><p>相当于 SQL99 中的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> player <span style="color:#66d9ef">RIGHT</span> <span style="color:#66d9ef">JOIN</span> team <span style="color:#66d9ef">on</span> player.team_id <span style="color:#f92672">=</span> team.team_id
</code></pre></div><p>需要注意的是，LEFT JOIN 和 RIGHT JOIN 只存在于 SQL99 及以后的标准中，在 SQL92 中不存在，只能用（+）表示。</p>
<h3 id="自连接">自连接</h3>
<p>自连接可以对多个表进行操作，也可以对同一个表进行操作。也就是说查询条件使用了当前表的字段。</p>
<p>比如我们想要查看比布雷克·格里芬高的球员都有谁，以及他们的对应身高：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> b.player_name, b.height <span style="color:#66d9ef">FROM</span> player <span style="color:#66d9ef">as</span> a , player <span style="color:#66d9ef">as</span> b <span style="color:#66d9ef">WHERE</span> a.player_name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;布雷克 - 格里芬&#39;</span> <span style="color:#66d9ef">and</span> a.height <span style="color:#f92672">&lt;</span> b.height
</code></pre></div><p>如果不用自连接的话，需要采用两次 SQL 查询。首先需要查询布雷克·格里芬的身高。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> height <span style="color:#66d9ef">FROM</span> player <span style="color:#66d9ef">WHERE</span> player_name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;布雷克 - 格里芬&#39;</span>
</code></pre></div><p>运行结果为 2.08。</p>
<p>然后再查询比 2.08 高的球员都有谁，以及他们的对应身高：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> player_name, height <span style="color:#66d9ef">FROM</span> player <span style="color:#66d9ef">WHERE</span> height <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">2</span>.<span style="color:#ae81ff">08</span>
</code></pre></div><h3 id="练习-4">练习</h3>
<p>现有<a href="https://github.com/cystanford/sql_nba_data/blob/master/team.sql">team表格</a>的sql语句：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SET</span> <span style="color:#66d9ef">NAMES</span> utf8mb4;
<span style="color:#66d9ef">SET</span> FOREIGN_KEY_CHECKS <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

<span style="color:#75715e">-- ----------------------------
</span><span style="color:#75715e">-- Table structure for team
</span><span style="color:#75715e">-- ----------------------------
</span><span style="color:#75715e"></span><span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#66d9ef">IF</span> <span style="color:#66d9ef">EXISTS</span> <span style="color:#f92672">`</span>team<span style="color:#f92672">`</span>;
<span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#f92672">`</span>team<span style="color:#f92672">`</span>  (
  <span style="color:#f92672">`</span>team_id<span style="color:#f92672">`</span> int(<span style="color:#ae81ff">11</span>) <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span> <span style="color:#66d9ef">COMMENT</span> <span style="color:#e6db74">&#39;球队ID&#39;</span>,
  <span style="color:#f92672">`</span>team_name<span style="color:#f92672">`</span> varchar(<span style="color:#ae81ff">255</span>) CHARACTER <span style="color:#66d9ef">SET</span> utf8 <span style="color:#66d9ef">COLLATE</span> utf8_general_ci <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span> <span style="color:#66d9ef">COMMENT</span> <span style="color:#e6db74">&#39;球队名称&#39;</span>,
  <span style="color:#66d9ef">PRIMARY</span> <span style="color:#66d9ef">KEY</span> (<span style="color:#f92672">`</span>team_id<span style="color:#f92672">`</span>) <span style="color:#66d9ef">USING</span> BTREE
) ENGINE <span style="color:#f92672">=</span> InnoDB CHARACTER <span style="color:#66d9ef">SET</span> <span style="color:#f92672">=</span> utf8 <span style="color:#66d9ef">COLLATE</span> <span style="color:#f92672">=</span> utf8_general_ci ROW_FORMAT <span style="color:#f92672">=</span> <span style="color:#66d9ef">Dynamic</span>;

<span style="color:#75715e">-- ----------------------------
</span><span style="color:#75715e">-- Records of team
</span><span style="color:#75715e">-- ----------------------------
</span><span style="color:#75715e"></span><span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> <span style="color:#f92672">`</span>team<span style="color:#f92672">`</span> <span style="color:#66d9ef">VALUES</span> (<span style="color:#ae81ff">1001</span>, <span style="color:#e6db74">&#39;底特律活塞&#39;</span>);
<span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> <span style="color:#f92672">`</span>team<span style="color:#f92672">`</span> <span style="color:#66d9ef">VALUES</span> (<span style="color:#ae81ff">1002</span>, <span style="color:#e6db74">&#39;印第安纳步行者&#39;</span>);
<span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> <span style="color:#f92672">`</span>team<span style="color:#f92672">`</span> <span style="color:#66d9ef">VALUES</span> (<span style="color:#ae81ff">1003</span>, <span style="color:#e6db74">&#39;亚特兰大老鹰&#39;</span>);

<span style="color:#66d9ef">SET</span> FOREIGN_KEY_CHECKS <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</code></pre></div><p>即：
<img src="SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4.assets/image-20230524121506900.png" alt=""></p>
<p>要求：表格中一共有 3 支球队，现在这 3 支球队需要进行比赛，请用一条 SQL 语句显示出所有可能的比赛组合。</p>
<ol>
<li>
<p>区分主客场</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> t1.team_name, t2.team_name <span style="color:#66d9ef">FROM</span> team <span style="color:#66d9ef">AS</span> t1 <span style="color:#66d9ef">LEFT</span> <span style="color:#66d9ef">JOIN</span> team <span style="color:#66d9ef">AS</span> t2 <span style="color:#66d9ef">ON</span> t1.team_id <span style="color:#f92672">!=</span> t2.team_id
</code></pre></div></li>
<li>
<p>不重复的两个球队的比赛</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> t1.team_name, t2.team_name <span style="color:#66d9ef">FROM</span> team <span style="color:#66d9ef">AS</span> t1, team <span style="color:#66d9ef">AS</span> t2 <span style="color:#66d9ef">WHERE</span> t1.team_id <span style="color:#f92672">&lt;</span> t2.team_id
</code></pre></div></li>
</ol>
<h2 id="sql99">SQL99</h2>
<p>现有三张数据表：player、team、height_grades</p>
<ul>
<li>
<p>player
<img src="SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4.assets/image-20230524124058988.png" alt=""></p>
</li>
<li>
<p>team
<img src="SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4.assets/image-20230524123936090.png" alt=""></p>
</li>
<li>
<p>height_grades
<img src="SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4.assets/image-20230524124015591.png" alt=""></p>
</li>
</ul>
<h3 id="交叉连接cross-join">交叉连接(CROSS JOIN)</h3>
<p>交叉连接实际上就是 SQL92 中的笛卡尔乘积，只是这里我们采用的是 CROSS JOIN。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> player <span style="color:#66d9ef">CROSS</span> <span style="color:#66d9ef">JOIN</span> team
</code></pre></div><p>运行结果（一共 37*3=111 条记录）：
<img src="SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4.assets/image-20230524124322104.png" alt=""></p>
<p>如果多张表进行交叉连接，比如表 t1，表 t2，表 t3 进行交叉连接，可以写成下面这样：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> t1 <span style="color:#66d9ef">CROSS</span> <span style="color:#66d9ef">JOIN</span> t2 <span style="color:#66d9ef">CROSS</span> <span style="color:#66d9ef">JOIN</span> t3
</code></pre></div><h3 id="自然连接">自然连接</h3>
<p>自然连接即为 SQL92 中的等值连接。<strong>它会帮你自动查询两张连接表中所有相同的字段，然后进行等值连接。</strong></p>
<p>如果我们想把 player 表和 team 表进行等值连接，相同的字段是 team_id。还记得在 SQL92 标准中，是如何编写的么？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> player_id, a.team_id, player_name, height, team_name <span style="color:#66d9ef">FROM</span> player <span style="color:#66d9ef">as</span> a, team <span style="color:#66d9ef">as</span> b <span style="color:#66d9ef">WHERE</span> a.team_id <span style="color:#f92672">=</span> b.team_id
</code></pre></div><p>在 SQL99 中你可以写成：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> player_id, team_id, player_name, height, team_name <span style="color:#66d9ef">FROM</span> player <span style="color:#66d9ef">NATURAL</span> <span style="color:#66d9ef">JOIN</span> team 
</code></pre></div><p>实际上，在 SQL99 中用 NATURAL JOIN 替代了 <code>WHERE player.team_id = team.team_id</code>。</p>
<h3 id="on连接">ON连接</h3>
<p>ON 连接用来指定我们想要的连接条件，针对上面的例子，它同样可以帮助我们实现自然连接的功能：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> player_id, player.team_id, player_name, height, team_name <span style="color:#66d9ef">FROM</span> player <span style="color:#66d9ef">JOIN</span> team <span style="color:#66d9ef">ON</span> player.team_id <span style="color:#f92672">=</span> team.team_id
</code></pre></div><p>这里我们指定了连接条件是<code>ON player.team_id = team.team_id</code>，相当于是用 ON 进行了 team_id 字段的等值连接。</p>
<p><strong>也可以 ON 连接进行非等值连接</strong>，比如我们想要查询球员的身高等级，需要用 player 和 height_grades 两张表：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> p.player_name, p.height, h.height_level
<span style="color:#66d9ef">FROM</span> player <span style="color:#66d9ef">AS</span> p <span style="color:#66d9ef">JOIN</span> height_grades <span style="color:#66d9ef">AS</span> h
<span style="color:#66d9ef">ON</span> height <span style="color:#66d9ef">BETWEEN</span> h.height_lowest <span style="color:#66d9ef">AND</span> h.height_highest
</code></pre></div><p>这个语句的运行结果和我们之前采用 SQL92 标准的查询结果一样。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> p.player_name, p.height, h.height_level
<span style="color:#66d9ef">FROM</span> player <span style="color:#66d9ef">AS</span> p, height_grades <span style="color:#66d9ef">AS</span> h
<span style="color:#66d9ef">WHERE</span> p.height <span style="color:#66d9ef">BETWEEN</span> h.height_lowest <span style="color:#66d9ef">AND</span> h.height_highest
</code></pre></div><p>一般来说在 SQL99 中，我们需要连接的表会采用 JOIN 进行连接，ON 指定了连接条件，后面可以是等值连接，也可以采用非等值连接。</p>
<h3 id="using-连接">USING 连接</h3>
<p>当我们进行连接的时候，可以用 USING 指定数据表里的同名字段进行等值连接。比如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> player_id, team_id, player_name, height, team_name <span style="color:#66d9ef">FROM</span> player <span style="color:#66d9ef">JOIN</span> team <span style="color:#66d9ef">USING</span>(team_id)
</code></pre></div><p>你能看出与自然连接 NATURAL JOIN 不同的是，USING 指定了具体的相同的字段名称，你需要在 USING 的括号 () 中填入要指定的同名字段。同时使用 JOIN USING 可以简化 JOIN ON 的等值连接，它与下面的 SQL 查询结果是相同的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> player_id, player.team_id, player_name, height, team_name <span style="color:#66d9ef">FROM</span> player <span style="color:#66d9ef">JOIN</span> team <span style="color:#66d9ef">ON</span> player.team_id <span style="color:#f92672">=</span> team.team_id
</code></pre></div><h3 id="外连接-1">外连接</h3>
<ol>
<li>
<p>左外连接</p>
<p>LEFT JOIN 或 LEFT OUTER JOIN</p>
<p>eg:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> player <span style="color:#66d9ef">LEFT</span> <span style="color:#66d9ef">JOIN</span> team <span style="color:#66d9ef">ON</span> player.team_id <span style="color:#f92672">=</span> team.team_id
</code></pre></div></li>
<li>
<p>右外连接</p>
<p>RIGHT JOIN 或 RIGHT OUTER JOIN</p>
<p>eg:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> player <span style="color:#66d9ef">RIGHT</span> <span style="color:#66d9ef">JOIN</span> team <span style="color:#66d9ef">ON</span> player.team_id <span style="color:#f92672">=</span> team.team_id
</code></pre></div></li>
<li>
<p>全外连接</p>
<p>FULL JOIN 或 FULL OUTER JOIN</p>
<p>eg:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> player <span style="color:#66d9ef">FULL</span> <span style="color:#66d9ef">JOIN</span> team <span style="color:#66d9ef">ON</span> player.team_id <span style="color:#f92672">=</span> team.team_id
</code></pre></div></li>
</ol>
<p>⚠️需要注意的是 MySQL 不支持全外连接，否则的话全外连接会返回左表和右表中的所有行。当表之间有匹配的行，会显示内连接的结果。当某行在另一个表中没有匹配时，那么会把另一个表中选择的列显示为空值。也就是说，全外连接的结果 = 左右表匹配的数据 + 左表没有匹配到的数据 + 右表没有匹配到的数据。</p>
<h3 id="自连接-1">自连接</h3>
<p>自连接的原理在 SQL92 和 SQL99 中都是一样的，只是表述方式不同。</p>
<p>比如我们想要查看比布雷克·格里芬身高高的球员都有哪些，在两个 SQL 标准下的查询如下。</p>
<p><strong>SQL92</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> b.player_name, b.height <span style="color:#66d9ef">FROM</span> player <span style="color:#66d9ef">as</span> a , player <span style="color:#66d9ef">as</span> b <span style="color:#66d9ef">WHERE</span> a.player_name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;布雷克 - 格里芬&#39;</span> <span style="color:#66d9ef">and</span> a.height <span style="color:#f92672">&lt;</span> b.height
</code></pre></div><p><strong>SQL99</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> b.player_name, b.height <span style="color:#66d9ef">FROM</span> player <span style="color:#66d9ef">as</span> a <span style="color:#66d9ef">JOIN</span> player <span style="color:#66d9ef">as</span> b <span style="color:#66d9ef">ON</span> a.player_name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;布雷克 - 格里芬&#39;</span> <span style="color:#66d9ef">and</span> a.height <span style="color:#f92672">&lt;</span> b.height
</code></pre></div><p>运行结果（6 条记录）：</p>
<p><img src="SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4.assets/image-20230607164635129.png" alt=""></p>
<h2 id="区别">区别</h2>
<p>至此我们讲解完了 SQL92 和 SQL99 标准下的连接查询，它们都对连接进行了定义，只是操作的方式略有不同。我们再来回顾下，这些连接操作基本上可以分成三种情况：</p>
<ol>
<li>内连接：将多个表之间满足连接条件的数据行查询出来。它包括了等值连接、非等值连接和自连接。</li>
<li>外连接：会返回一个表中的所有记录，以及另一个表中匹配的行。它包括了左外连接、右外连接和全连接。</li>
<li>交叉连接：也称为笛卡尔积，返回左表中每一行与右表中每一行的组合。在 SQL99 中使用的 CROSS JOIN。</li>
</ol>
<p>不过 SQL92 在这三种连接操作中，和 SQL99 还存在着明显的区别。</p>
<p>首先我们看下 SQL92 中的 WHERE 和 SQL99 中的 JOIN。</p>
<p>你能看出在 SQL92 中进行查询时，会把所有需要连接的表都放到 FROM 之后，然后在 WHERE 中写明连接的条件。而 SQL99 在这方面更灵活，它不需要一次性把所有需要连接的表都放到 FROM 之后，而是采用 JOIN 的方式，每次连接一张表，可以多次使用 JOIN 进行连接。</p>
<p>另外，我建议多表连接使用 SQL99 标准，因为层次性更强，可读性更强，比如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> ...
<span style="color:#66d9ef">FROM</span> table1
    <span style="color:#66d9ef">JOIN</span> table2 <span style="color:#66d9ef">ON</span> table1 <span style="color:#960050;background-color:#1e0010">和</span> table2 <span style="color:#960050;background-color:#1e0010">的连接条件</span>
        <span style="color:#66d9ef">JOIN</span> table3 <span style="color:#66d9ef">ON</span> table2 <span style="color:#960050;background-color:#1e0010">和</span> table3 <span style="color:#960050;background-color:#1e0010">的连接条件</span>
</code></pre></div><p>它的嵌套逻辑类似我们使用的 FOR 循环：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">for</span> t1 <span style="color:#66d9ef">in</span> table1:
    <span style="color:#66d9ef">for</span> t2 <span style="color:#66d9ef">in</span> table2:
       <span style="color:#66d9ef">if</span> condition1:
           <span style="color:#66d9ef">for</span> t3 <span style="color:#66d9ef">in</span> table3:
              <span style="color:#66d9ef">if</span> condition2:
                  <span style="color:#66d9ef">output</span> t1 <span style="color:#f92672">+</span> t2 <span style="color:#f92672">+</span> t3
</code></pre></div><p>SQL99 采用的这种嵌套结构非常清爽，即使再多的表进行连接也都清晰可见。如果你采用 SQL92，可读性就会大打折扣。</p>
<p>最后一点就是，SQL99 在 SQL92 的基础上提供了一些特殊语法，比如 NATURAL JOIN 和 JOIN USING。它们在实际中是比较常用的，省略了 ON 后面的等值条件判断，让 SQL 语句更加简洁。</p>
<h2 id="不同-dbms-中使用连接需要注意的地方">不同 DBMS 中使用连接需要注意的地方</h2>
<p>SQL 连接具有通用性，但是不同的 DBMS 在使用规范上会存在差异，在标准支持上也存在不同。在实际工作中，你需要参考你正在使用的 DBMS 文档，这里我整理了一些需要注意的常见的问题。</p>
<p><strong>1. 不是所有的 DBMS 都支持全外连接</strong></p>
<p>虽然 SQL99 标准提供了全外连接，但不是所有的 DBMS 都支持。不仅 MySQL 不支持，Access、SQLite、MariaDB 等数据库软件也不支持。不过在 Oracle、DB2、SQL Server 中是支持的。</p>
<p><strong>2.Oracle 没有表别名 AS</strong></p>
<p>为了让 SQL 查询语句更简洁，我们经常会使用表别名 AS，不过在 Oracle 中是不存在 AS 的，使用表别名的时候，直接在表名后面写上表别名即可，比如 player p，而不是 player AS p。</p>
<p><strong>3.SQLite 的外连接只有左连接</strong></p>
<p>SQLite 是一款轻量级的数据库软件，在外连接上只支持左连接，不支持右连接，不过如果你想使用右连接的方式，比如<code>table1 RIGHT JOIN table2</code>，在 SQLite 你可以写成<code>table2 LEFT JOIN table1</code>，这样就可以得到相同的效果。</p>
<p>除了一些常见的语法问题，还有一些关于连接的性能问题需要你注意：</p>
<p><strong>1. 控制连接表的数量</strong></p>
<p>多表连接就相当于嵌套 for 循环一样，非常消耗资源，会让 SQL 查询性能下降得很严重，因此不要连接不必要的表。在许多 DBMS 中，也都会有最大连接表的限制。</p>
<p><strong>2. 在连接时不要忘记 WHERE 语句</strong></p>
<p>多表连接的目的不是为了做笛卡尔积，而是筛选符合条件的数据行，因此在多表连接的时候不要忘记了 WHERE 语句，这样可以过滤掉不必要的数据行返回。</p>
<p><strong>3. 使用自连接而不是子查询</strong></p>
<p>我们在查看比布雷克·格里芬高的球员都有谁的时候，可以使用子查询，也可以使用自连接。一般情况建议你使用自连接，因为在许多 DBMS 的处理过程中，对于自连接的处理速度要比子查询快得多。你可以这样理解：子查询实际上是通过未知表进行查询后的条件判断，而自连接是通过已知的自身数据表进行条件判断，因此在大部分 DBMS 中都对自连接处理进行了优化。</p>
<h2 id="总结">总结</h2>
<p>连接可以说是 SQL 中的核心操作，通过两篇文章的学习，你已经从多个维度对连接进行了了解。同时，我们对 SQL 的两个重要标准 SQL92 和 SQL99 进行了学习，在我们需要进行外连接的时候，建议采用 SQL99 标准，这样更适合阅读。</p>
<p>此外我还想强调一下，我们在进行连接的时候，使用的关系型数据库管理系统，之所以存在关系是因为各种数据表之间存在关联，它们并不是孤立存在的。在实际工作中，尤其是做业务报表的时候，我们会用到 SQL 中的连接操作（JOIN），因此我们需要理解和熟练掌握 SQL 标准中连接的使用，以及不同 DBMS 中对连接的语法规范。剩下要做的，就是通过做练习和实战来增强你的经验了，做的练习多了，也就自然有感觉了。</p>
<h2 id="练习-5">练习</h2>
<p>编写 SQL 查询语句，查询不同身高级别（对应 height_grades 表）对应的球员数量（对应 player 表）</p>
<p>参考：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> height_level,<span style="color:#66d9ef">COUNT</span>(height_level)
<span style="color:#66d9ef">FROM</span> player <span style="color:#66d9ef">JOIN</span> height_grades
<span style="color:#66d9ef">ON</span> player.height <span style="color:#66d9ef">BETWEEN</span> height_grades.height_lowest <span style="color:#66d9ef">AND</span> height_grades.height_highest
<span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span> height_level;
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> height_level, <span style="color:#66d9ef">COUNT</span>(player_name) <span style="color:#66d9ef">AS</span> player_num 
<span style="color:#66d9ef">FROM</span> player <span style="color:#66d9ef">AS</span> p <span style="color:#66d9ef">LEFT</span> <span style="color:#66d9ef">JOIN</span> height_grades <span style="color:#66d9ef">AS</span> h <span style="color:#66d9ef">ON</span> p.height <span style="color:#66d9ef">BETWEEN</span> h.height_lowest <span style="color:#66d9ef">AND</span> h.height_highest 
<span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span> height_level;
</code></pre></div><p>答疑里：</p>
<p>完整的SELECT语句内部执行顺序是：</p>
<ol>
<li>FROM子句组装数据（包括通过ON进行连接）</li>
<li>WHERE子句进行条件筛选</li>
<li>GROUP BY分组</li>
<li>使用聚集函数进行计算；</li>
<li>HAVING筛选分组；</li>
<li>计算所有的表达式；</li>
<li>SELECT 的字段；</li>
<li>ORDER BY排序</li>
<li>LIMIT筛选</li>
</ol>
</section>

  
  
  <footer class="post-tags">
     
    <a href="https://viaxiz.github.io/tags/%E5%AD%A6%E4%B9%A0">学习</a>
     
    <a href="https://viaxiz.github.io/tags/sql">SQL</a>
    
  </footer>
  

  
  
  
  <nav class="post-nav">
    
    <a class="prev" href="https://viaxiz.github.io/posts/tips/"><span>←</span><span>生活学习小技巧</span></a>
     
    <a class="next" href="https://viaxiz.github.io/posts/my-database/"><span>My Database: 写一个自己的数据库</span><span>→</span></a>
    
  </nav>
  

  
  
</article>

</main>

    <footer class="footer">
  <p>&copy; 2023 <a href="https://viaxiz.github.io/">viaxizhong</a></p>
  <p>Powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo️️</a>️</p>
  <p>
    <a href="https://github.com/nanxiaobei/hugo-paper" rel="noopener" target="_blank">Paper 5.1</a>
  </p>
</footer>

  </body>
</html>
